#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 3) in vec2 debug2; // Debug info (bones/weights)layout(location = 0) out vec4 outColor;layout(binding = 1, set = 1) uniform sampler2D tex;layout(binding = 0, set = 0) uniform GlobalUniformBufferObject {    vec3 lightDir;    vec4 lightColor;    vec3 eyePos;} gubo;const float PI = 3.14159265359;// --- PBR FUNCTIONS (Standard Cook-Torrance) ---// Normal Distribution functionfloat D_GGX(float dotNH, float roughness){    float alpha = roughness * roughness;    float alpha2 = alpha * alpha;    float denom = dotNH * dotNH * (alpha2 - 1.0f) + 1.0f;    return (alpha2)/(PI * denom*denom);}// Geometric Shadowing functionfloat G_SchlicksmithGGX(float dotNL, float dotNV, float roughness){    float r = (roughness + 1.0f);    float k = (r*r) / 8.0f;    float GL = dotNL / (dotNL * (1.0f - k) + k);    float GV = dotNV / (dotNV * (1.0f - k) + k);    return GL * GV;}// Fresnel functionvec3 F_Schlick(float cosTheta, float metallic, vec3 materialcolor){    vec3 F0 = mix(vec3(0.04f), materialcolor, metallic);    vec3 F = F0 + (vec3(1.0f) - F0) * pow(1.0f - cosTheta, 5.0f);    return F;}// Specular BRDF compositionvec3 BRDF(vec3 L, vec3 V, vec3 N, float metallic, float roughness, vec3 materialcolor){    vec3 H = normalize (V + L);    float dotNV = clamp(dot(N, V), 0.0f, 1.0f);    float dotNL = clamp(dot(N, L), 0.0f, 1.0f);    float dotLH = clamp(dot(L, H), 0.0f, 1.0f);    float dotNH = clamp(dot(N, H), 0.0f, 1.0f);    vec3 color = vec3(0.0f);    if (dotNL > 0.0f)    {       float rroughness = max(0.05f, roughness);       float D = D_GGX(dotNH, roughness);       float G = G_SchlicksmithGGX(dotNL, dotNV, rroughness);       vec3 F = F_Schlick(dotNV, metallic, materialcolor);       vec3 spec = D * F * G / (4.0f * dotNV);       color += spec;    }    return color;}void main() {    vec3 Norm = normalize(fragNorm);    vec3 EyeDir = normalize(gubo.eyePos - fragPos);    vec3 lightDir = normalize(gubo.lightDir);    vec3 lightColor = gubo.lightColor.rgb;    vec3 albedo = texture(tex, fragUV).rgb;    // Previous values were: metallic 0.9, roughness 0.2 (Chrome/Mirror).    // New values:    // Metallic = 0.0 (Skin/Cloth is dielectric, not metal)    // Roughness = 0.8 (Matte surface, soft reflection)    float metallic = 0.0f;    float roughness = 0.8f;    // Calculate PBR Specular (Soft highlight for volume)    vec3 Specular = BRDF(lightDir, EyeDir, Norm, metallic, roughness, albedo);    // Calculate Diffuse (The Sun)    vec3 Diffuse = albedo * clamp(dot(Norm, lightDir), 0.0f, 1.0f);    // Replaced the old static 'cxp/cxn' code.    // Now creates a gradient based on Sky vs Ground, tinted by the Day/Night cycle.    // upFactor: 1.0 = Sky, 0.0 = Ground    float upFactor = Norm.y * 0.5 + 0.5;    // Ambient colors derived from global light color    vec3 skyColor = lightColor * 0.4;    vec3 groundColor = vec3(0.1, 0.1, 0.1) * length(lightColor);    // Mix and apply to texture    vec3 Ambient = mix(groundColor, skyColor, upFactor) * albedo * 0.5;    // Final color sum    vec3 col  = (Diffuse + Specular) * lightColor + Ambient;    // Output with Debug Logic preserved    outColor = vec4(col * (1.0f - debug2.x) + vec3(debug2.x * debug2.y, 0.0f, 0.0f), 1.0f);}