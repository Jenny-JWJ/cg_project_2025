#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 3) in vec2 debug2; // Original debug info for bone/weight visualizationlayout(location = 0) out vec4 outColor;// --- STRUCTURES ---struct PointLight {    vec3 position;    float padding1; // Aligns with C++ alignas(16)    vec3 color;    float padding2; // Aligns with C++ alignas(16)};// --- UNIFORM BLOCKS ---// Set 1, Binding 0: Character Local Uniforms (Matrices and Alpha)layout(binding = 0, set = 1) uniform UniformBufferObjectChar {    vec4 debug1; // debug1.w contains playerAlpha for dithering    mat4 mvpMat[65];    mat4 mMat[65];    mat4 nMat[65];} ubo;layout(binding = 1, set = 1) uniform sampler2D tex;// Set 0, Binding 0: Global Environment Uniformslayout(binding = 0, set = 0) uniform GlobalUniformBufferObject {    vec3 lightDir;    vec4 lightColor;    vec3 eyePos;} gubo;// Set 0, Binding 1: Point Lights for the lampslayout(binding = 1, set = 0) uniform PointLightBufferObject {    PointLight lights[100];    int numActiveLights;} plbo;const float PI = 3.14159265359;// --- PBR FUNCTIONS ---float D_GGX(float dotNH, float roughness) {    float alpha = roughness * roughness;    float alpha2 = alpha * alpha;    float denom = dotNH * dotNH * (alpha2 - 1.0f) + 1.0f;    return (alpha2) / (PI * denom * denom);}float G_SchlicksmithGGX(float dotNL, float dotNV, float roughness) {    float r = (roughness + 1.0f);    float k = (r * r) / 8.0f;    float GL = dotNL / (dotNL * (1.0f - k) + k);    float GV = dotNV / (dotNV * (1.0f - k) + k);    return GL * GV;}vec3 F_Schlick(float cosTheta, float metallic, vec3 materialcolor) {    vec3 F0 = mix(vec3(0.04f), materialcolor, metallic);    return F0 + (vec3(1.0f) - F0) * pow(1.0f - cosTheta, 5.0f);}vec3 BRDF(vec3 L, vec3 V, vec3 N, float metallic, float roughness, vec3 materialcolor) {    vec3 H = normalize(V + L);    float dotNV = clamp(dot(N, V), 0.0f, 1.0f);    float dotNL = clamp(dot(N, L), 0.0f, 1.0f);    float dotNH = clamp(dot(N, H), 0.0f, 1.0f);    if (dotNL > 0.0f) {        float rroughness = max(0.05f, roughness);        float D = D_GGX(dotNH, rroughness);        float G = G_SchlicksmithGGX(dotNL, dotNV, rroughness);        vec3 F = F_Schlick(dotNV, metallic, materialcolor);        return D * F * G / (4.0f * max(dotNV, 0.001f));    }    return vec3(0.0f);}void main() {    // 1. DITHERING (TRANSPARENCY FOR CAMERA CLIPPING)    float alpha = ubo.debug1.w;    if (alpha < 1.0) {        mat4 dither = mat4(            0.0625, 0.5625, 0.1875, 0.6875,            0.8125, 0.3125, 0.9375, 0.4375,            0.25,   0.75,   0.125,  0.625,            1.0,    0.5,    0.875,  0.375        );        int x = int(mod(gl_FragCoord.x, 4.0));        int y = int(mod(gl_FragCoord.y, 4.0));        if (alpha < dither[x][y]) { discard; }    }    // 2. SETUP VECTORS & MATERIAL PROPERTIES    vec3 N = normalize(fragNorm);    vec3 V = normalize(gubo.eyePos - fragPos);    vec3 albedo = texture(tex, fragUV).rgb;    // Calibrated matte look to avoid the "oily" effect    float charMetallic = 0.0f;    float charRoughness = 0.65f;    // 3. SUN LIGHT (DIRECTIONAL)    vec3 L_sun = normalize(gubo.lightDir);    vec3 sunColor = gubo.lightColor.rgb;    vec3 sunSpecular = BRDF(L_sun, V, N, charMetallic, charRoughness, albedo);    vec3 sunDiffuse = albedo * clamp(dot(N, L_sun), 0.0f, 1.0f);    vec3 totalCol = (sunDiffuse + sunSpecular) * sunColor;    // 4. POINT LIGHTS (LAMPS WITH WARMTH BOOST)    for (int i = 0; i < plbo.numActiveLights; i++) {        vec3 L_lamp = normalize(plbo.lights[i].position - fragPos);        float dist = length(plbo.lights[i].position - fragPos);        float range = 13.0; // Distance of the light reach        // Smooth range-based attenuation        float attenuation = clamp(1.0 - (dist / range), 0.0, 1.0);        attenuation *= attenuation;        // Apply WARMTH trick: boost Reds and lower Blues slightly for a cozy glow        vec3 lampColor = plbo.lights[i].color * attenuation;        vec3 warmTint = vec3(1.1, 0.95, 0.8);        lampColor *= warmTint;        vec3 pSpecular = BRDF(L_lamp, V, N, charMetallic, charRoughness, albedo);        vec3 pDiffuse = albedo * clamp(dot(N, L_lamp), 0.0f, 1.0f);        // 1.5x boost to make lamps stand out against ambient light        totalCol += (pDiffuse + pSpecular) * lampColor * 1.5;    }    // 5. AMBIENT GRADIENT & NIGHT VISIBILITY FILL    float upFactor = N.y * 0.5f + 0.5f;    vec3 skyColor = sunColor * 0.4f;    vec3 groundColor = vec3(0.1f) * length(sunColor);    // Character Fill Light: ensure the player is never pitch black    vec3 nightFillColor = vec3(0.05, 0.05, 0.07);    vec3 baseAmbient = max(mix(groundColor, skyColor, upFactor), nightFillColor);    vec3 Ambient = baseAmbient * albedo * 0.6f;    // Suble Rim Light to define the silhouette in the dark    float rim = pow(1.0 - clamp(dot(N, V), 0.0, 1.0), 4.0);    vec3 finalCol = totalCol + Ambient + (nightFillColor * rim * 0.5);    // 6. FINAL OUTPUT (WITH DEBUG BONES)    outColor = vec4(finalCol * (1.0f - debug2.x) + vec3(debug2.x * debug2.y, 0.0f, 0.0f), 1.0f);}