#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 0) out vec4 outColor;layout(binding = 1, set = 1) uniform sampler2D tex;layout(binding = 2, set = 1) uniform sampler2D detail;layout(binding = 0, set = 0) uniform GlobalUniformBufferObject {    vec3 lightDir;    vec4 lightColor;    vec3 eyePos;} gubo;// --- POINT LIGHTS DATA ---#define NR_POINT_LIGHTS 100struct PointLight {    vec3 position;    vec3 color;};// Set 0, Binding 3 matches the C++ descriptor updatelayout(binding = 1, set = 0) uniform PointLightsBuffer {    PointLight lights[NR_POINT_LIGHTS];    int numActiveLights;} plb;void main() {    vec3 Norm = normalize(fragNorm);    vec3 albedo = texture(tex, fragUV).rgb;    // SUN LIGHT (Original Logic)    vec3 sunDir = normalize(gubo.lightDir);    float diffFactor = max(dot(Norm, sunDir), 0.0);    vec3 SunDiffuse = diffFactor * gubo.lightColor.rgb * albedo;    // AMBIENT LIGHT (Original Hemispheric Logic)    float upFactor = Norm.y * 0.5 + 0.5;    vec3 skyColor = gubo.lightColor.rgb * 0.4;    vec3 groundColor = vec3(0.1) * length(gubo.lightColor.rgb);    vec3 Ambient = mix(groundColor, skyColor, upFactor) * albedo * 1;    // LAMP LIGHTS (Point Lights)        vec3 PointLightsResult = vec3(0.0);        for(int i = 0; i < plb.numActiveLights; i++) {            vec3 L_vec = plb.lights[i].position - fragPos;            float dist = length(L_vec);            vec3 L = normalize(L_vec);            // New Attenuation: more gradual falloff to reach further objects            // Formula: 1.0 / (1.0 + 0.07 * dist + 0.017 * dist * dist)            float attenuation = 1.0 / (1.0 + 0.07 * dist + 0.017 * dist * dist);            float lampDiff = max(dot(Norm, L), 0.0);            // Added a 2.5x boost to the final contribution            PointLightsResult += plb.lights[i].color * lampDiff * albedo * attenuation * 1.0;        }    // Final Color = Sun + Ambient + Lamps    outColor = vec4(SunDiffuse + Ambient + PointLightsResult, 1.0f);}