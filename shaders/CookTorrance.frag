#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 0) out vec4 outColor;layout(binding = 1, set = 1) uniform sampler2D tex;// Detail texture is kept in the binding to avoid errors, but ignored to prevent "black streak" artifactslayout(binding = 2, set = 1) uniform sampler2D detail;layout(binding = 0, set = 0) uniform GlobalUniformBufferObject {    vec3 lightDir;    vec4 lightColor;    vec3 eyePos;} gubo;void main() {    vec3 Norm = normalize(fragNorm);    // We normalize the light direction.    // CRITICAL: We do NOT use 'eyePos' here. This ensures lighting is anchored to the world,    // preventing shadows/reflections from moving when the camera moves.    vec3 lightDir = normalize(gubo.lightDir);    vec3 lightColor = gubo.lightColor.rgb;    // 1. Load Base Texture    // We only use the albedo texture. We removed the 'detail' noise texture    // because it was causing ugly stretching artifacts on vertical walls.    vec3 albedo = texture(tex, fragUV).rgb;    // 2. DIFFUSE LIGHTING (The Sun)    // Standard Lambertian reflection.    // We use max(..., 0.0) to clamp negative values, ensuring the dark side creates proper shadows    // instead of graphical glitches (weird black artifacts).    float diffFactor = max(dot(Norm, lightDir), 0.0);    vec3 Diffuse = diffFactor * lightColor * albedo;    // 3. AMBIENT LIGHTING (The Volume)    // To restore 3D volume without using Specular (which causes "moving" reflections),    // we use Hemispheric Ambient Lighting.    // This creates a gradient: surfaces facing Up (Sky) are lighter, surfaces facing Down (Ground) are darker.    // upFactor: 1.0 if facing the Sky, 0.0 if facing the Ground.    float upFactor = Norm.y * 0.5 + 0.5;    // Sky Color: Tinted by the global light (e.g., orange at sunset, blue at night)    vec3 skyColor = lightColor * 0.4;    // Ground Color: Darker and constant, simulating light absorption by the earth    vec3 groundColor = vec3(0.1, 0.1, 0.1) * length(lightColor);    // Mix the two colors based on the surface orientation    vec3 AmbientColor = mix(groundColor, skyColor, upFactor);    // Apply ambient to the texture    vec3 Ambient = AmbientColor * albedo * 0.5;    // Final Color Composition    // Diffuse (Sun) + Ambient (Sky/Ground fill)    vec3 col = Diffuse + Ambient;    outColor = vec4(col, 1.0f);}